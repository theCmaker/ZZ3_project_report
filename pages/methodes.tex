\chapter{Méthodes}
	\section{Heuristiques constructives}
		Nous proposons deux heuristiques d'insertion. La première est pilotée par l'utilisateur, et la seconde est autonome.

		Ces deux heuristiques servent à construire des solutions réalisables. L'optimalité de ces solutions n'est pas garantie et n'est pas un objectif. En effet, une heuristique est une étape de résolution qui vise seulement à produire une solution viable sur laquelle on pourra appliquer des modifications de manière itérative jusqu'à l'obtention d'un résultat répondant aux critères de qualité que l'on aura fixés.

		Il est très souvent plus facile d'améliorer un système dont on sait qu'il fonctionne que de chercher à rendre efficace un système défectueux.
		\subsection{Interception selon une séquence}
		\label{sub:heuristic_sequence}
			Dans cette heuristique, l'utilisateur fournit une séquence de mobiles à intercepter dans l'ordre de la lecture de cette séquence. L'heuristique est alors chargée pour chaque mobile de cette séquence de déterminer l'intercepteur capable de l'intercepter dans les meilleurs délais. On garantit alors la propriété suivante pour chaque tournée $r$:
			\[
				\forall i, j \qtext{t.q.}  i<j, \qtext{on a} \text{pos}(r_i) < \text{pos}(r_j)
			\]
			avec $r_k$ le mobile intercepté en $k$\ieme{} position dans la tournée $r$, et pos($r_k$) la fonction permettant d'obtenir la position du mobile $r_k$ dans la séquence imposée par l'utilisateur.

			La figure~\ref{fig:heuristic_sequence_demo} présente un exemple de solution réalisable.

			\begin{figure}[h!]
			\centering
			Séquence donnée: $\{4, 2, 3, 0, 1\}$

			\begin{tikzpicture}[schema]
				\input{example_heuristic_sequence}
			\end{tikzpicture}
			\caption{Exemple de solution réalisable pour l'heuristique ``Séquence''}
			\label{fig:heuristic_sequence_demo}
			\end{figure}

		\subsection{Interception au plus tôt}
		\label{sub:heuristic_fastest}
			Dans cette heuristique, le calcul de chaque interception est piloté par le temps. L'heuristique calcule pour chaque insertion les meilleurs candidats (mobile et tournée). Il s'agit donc de déterminer quel est le mobile qui pourra être inseré dans la tournée réalisée par l'intercepteur capable de le rejoindre au plus tôt. Il s'agit d'une méthode plus gourmande en ressources mais qui permet d'obtenir des résultats généralement de meilleure qualité que l'insertion par séquence.

			Afin d'optimiser les performances, nous avons développé une politique de \gls{cache} permettant de conserver une matrice des durées nécessaires pour atteindre chaque mobile à partir de chaque intercepteur. Ainsi lorsqu'un mobile est intercepté, seules les durées relatives à l'intercepteur candidat sont faussées et doivent être recalculées, les durées nécessaires aux autres intercepteurs pour atteindre les autres mobiles restent identiques. Nous décrivons plus en détail ce mécanisme dans l'annexe~\ref{app:cache}.

			Toutefois, cette heuristique doit être utilisée avec parcimonie en raison de son coût de calcul, mais aussi car elle n'est pas paramétrable et n'offre donc pas de capacités d'extension de ses possibilités, notamment le fait d'ignorer des mobiles ou de prioriser l'interception d'un mobile par rapport à un autre sur une décision arbitraire\ldots

			\begin{figure}[h!]
				\begin{subfigure}[t]{.5\linewidth}
					\centering
					\caption{Au plus tôt}
					\label{subfig:fastest_demo}
					\begin{tikzpicture}[scale=.5,baseline]
						\input{test_5m_2i_graph_fastest}
					\end{tikzpicture}
				\end{subfigure}
				\hfill
				\begin{subfigure}[t]{.5\linewidth}
					\centering
					\caption{Par séquence}
					\label{subfig:_sequence_demo}
					\begin{tikzpicture}[scale=.5,baseline]
						\tikzset{interceptor/.style = {thick, color=OrangeRed}}
						\input{test_5m_2i_graph_sequence}
					\end{tikzpicture}
				\end{subfigure}
				\caption{Application des heuristiques d'insertion}
				\label{fig:heuristics_demo}
			\end{figure}


	\section{Recherche Locale et optimisation bi-critères}
		La recherche locale vise à améliorer une solution en réalisant une succession de mutations simples. En effet, lorsque l'heuristique d'insertion se termine, deux cas se présentent:
		\begin{itemize}
			\item Tous les mobiles ont été interceptés,
			\item Il reste un ou plusieurs mobiles non-interceptés.
		\end{itemize}

		Dans le premier cas, le moyen le plus simple pour gagner du temps consiste à retirer un mobile, c'est le mouvement présenté dans la section \ref{subs:move_extract}. Dans le second cas, on peut essayer d'insérer les mobiles restants dans une tournée (section \ref{subs:move_insert}).

		Egalement, il est possible de combiner ces deux mouvements élémentaires pour former quel\-ques mouvements plus complexes, par exemple enlever un mobile pour le déplacer dans une autre tournée, ou ailleurs dans la même tournée. Nous présentons donc plusieurs mouvements que nous jugeons pertinents dans les sections suivantes.

		Remarquons que les mouvements ainsi décrits doivent être appliqués stratégiquement, l'objectif est d'améliorer la solution et non de la détériorer. Il convient donc de fixer les limites d'une détérioration que l'on jugera acceptable. L'intérêt d'accepter une légère détérioration est que cette détérioration ne peut être que temporaire, pour permettre un autre mouvement qui laissera ensuite envisager une amélioration plus forte.

		Les objectifs de qualité pour une solution sont le nombre de mobiles interceptés et la date de fin de la tournée la plus longue (en termes de durée). C'est la raison pour laquelle nous avons défini des politiques d'amélioration visant à atteindre ces objectifs qui sont mutuellement contradictoires, tout en garantissant que les limites de détérioration ne sont pas dépassées. Ces politiques définissent quelle est la solution à choisir et valident (ou invalides) des propositions de modifications. Elles sont décrites dans les sections \ref{subs:first_available_policy} et \ref{subs:best_available_policy}.

		\subsection{Mouvement d'extraction}
			Le mouvement d'extraction permet de retirer un mobile dans une tournée afin d'améliorer le plus grand temps d'interception. Pour cela, seule la suppression d'un mobile dans la tournée la plus longue en temps sera validée, car une extraction dans les autres tournées n'apporterait pas d'amélioration à la solution globale. Afin que ce mouvement ne vide pas successivement les tournées jusqu'à aboutir à une solution où aucun mobile n'est intercepté (solution triviale pour la minimisation du le temps), une politique a été ajoutée pour considérer le problème avec le critère de temps, mais aussi celui du nombre de mobiles. Un minimum est donc fixé pour ne pas aller en-dessous d'un certain seuil.
			
			
			L'algorithme de principe est le suivant :
			\begin{code}
				\begin{algo}[informal]
					\ALGO{Principe d'extraction d'un mobile dans une tournée}
					\BEGIN
						\STATE{Amélioration ← Faux}
						\STATE{Récupérer la pire tournée t en temps}
						\FORGEN{tous les mobiles m dans la tournée t faire}
							\STATE{Calculer le temps d'interception de la tournée sans le mobile m}
							\IF{le temps d'interception est fini et que la politique est respectée}
								\STATE{Amélioration ← Vrai}
							\ENDIF
						\ENDFORGEN
						\RETURN{Amélioration}
					\END
				\end{algo}
				\captionof{listing}{Algorithme de principe -- Extraction d'un mobile dans une tournée}
			\end{code}
			
			\label{subs:move_extract}
			\begin{figure}[h!]
			\centering
			\begin{tikzpicture}[schema]
				\input{move_extract}
			\end{tikzpicture}
			\caption{Schéma d'extraction d'un mobile hors d'une tournée}
			\label{fig:move_extract}
			\end{figure}

		\subsection{Mouvement d'insertion}
			Le mouvement d'insertion permet d'ajouter un mobile à une tournée. Il est donc forcément améliorant en terme de mobiles, mais il peut impacter le temps maximum d'interception. Ce mouvement sera donc validé uniquement s'il ne l'augmente pas.
			
			L'algorithme de principe est le suivant :
			\begin{code}
				\begin{algo}[informal]
					\ALGO{Principe d'insertion d'un mobile dans une tournée}
					\BEGIN
						\FORGEN{tous les mobiles non interceptés m}
							\FORGEN{toutes les tournées t}
								\FORGEN{toutes les positions p}
									\STATE{Calculer le temps d'interception en insérant m dans t à la position p}
									\IF{l'insertion est possible (le temps est fini)}
										\STATE{Comparer le résultat obtenu avec le temps initial (avec arrêt de la recherche selon les politiques)}
									\ENDIF
								\ENDFORGEN
							\ENDFORGEN
						\ENDFORGEN
						\RETURN{vrai s'il y a eu amélioration, faux sinon}
					\END
				\end{algo}
				\captionof{listing}{Algorithme de principe -- Insertion d'un mobile dans une tournée}
			\end{code}
					
		
			\label{subs:move_insert}
			\begin{figure}[h!]
			\centering
			\begin{tikzpicture}[schema]
				\input{move_insert}
			\end{tikzpicture}
			\caption{Schéma d'insertion d'un mobile dans une tournée}
			\label{fig:move_insert}
			\end{figure}

		\subsection{Mouvement de substitution (ou remplacement)}
				Le mouvement de substitution permet d'insérer un mobile à la place d'un autre mobile dans une tournée. Il s''agit donc d'un mouvement de suppression suivi d'un mouvement d'insertion. Comme le nombre de mobile ne change pas, seul le gain de temps est considéré pour valider ou non l'opération.
				
				L'algorithme de principe est le suivant :
				\begin{code}
					\begin{algo}[informal]
						\ALGO{Principe du remplacement dans une tournée}
						\BEGIN
							\FORGEN{tous les mobiles non interceptés m}
								\FORGEN{toutes les tournées t}
									\FORGEN{tous les mobiles m' dans t'}
										\STATE{Calculer le temps d'interception en remplaçant m' par m dans t}
										\STATE{Comparer le résultat obtenu avec le temps initial (avec arrêt de la recherche selon les politiques)}
									\ENDFORGEN
								\ENDFORGEN
							\ENDFORGEN
							\RETURN{vrai s'il y a eu amélioration, faux sinon}
						\END
					\end{algo}
				\captionof{listing}{Algorithme de principe -- Remplacement d'un mobile dans une tournée}
			\end{code}
			
			\begin{figure}[h!]
			\centering
			\begin{tikzpicture}[schema]
				\input{move_replace}
			\end{tikzpicture}
			\caption{Schéma de substitution d'un mobile dans une tournée}
			\label{fig:move_replace}
			\end{figure}

		\subsection{Mouvements de déplacement}
			Le mouvement de déplacement d'un mobile dans une tournée consiste à changer de position l'un des mobiles au sein de la même tournée. L'objectif est de trouver une meilleure organisation de la tournée et donc d'obtenir un gain de temps sur la date d'interception finale.

			L'algorithme de principe est le suivant:
			\begin{code}
				\begin{algo}[informal]
					\ALGO{Principe du déplacement dans une tournée}
					\BEGIN
						\FORGEN{toutes les tournées t}
							\FORGEN{toutes les positions possibles dans t}
								\FORGEN{tous les mobiles m}
									\IF{le déplacement existe}
										\STATE{Calculer le nouveau temps d'interception de t avec le déplacement de m dans la tournée.}
										\STATE{Comparer le résultat obtenu avec le temps initial (avec arrêt de la recherche selon les politiques)}
									\ENDIF
								\ENDFORGEN
							\ENDFORGEN
						\ENDFORGEN
						\RETURN{vrai s'il y a eu amélioration, faux sinon}
					\END
				\end{algo}
				\captionof{listing}{Algorithme de principe -- Déplacement au sein d'une tournée}
			\end{code}


			Le mouvement de déplacement d'un mobile dans une autre tournée consiste à supprimer un mobile de sa tournée pour l'insérer dans une seconde tournée.

			L'algorithme de principe est le suivant :
			\begin{code}
				\begin{algo}[informal]
					\ALGO{Principe du déplacement dans deux tournées}
					\BEGIN
						\FORGEN{toutes les tournées t1}
							\FORGEN{tous les mobiles m dans t1}
								\FORGEN{toutes les tournées t2}
									\FORGEN{toutes les positions dans t2}
										\STATE{Calculer le nouveau temps d'interception de t2 avec l'insertion de m à la position p}
										\STATE{Comparer le résultat obtenu avec le temps inital (avec arrêt de la recherche selon les politiques)}
									\ENDFORGEN
								\ENDFORGEN
							\ENDFORGEN
						\ENDFORGEN
						\RETURN{vrai s'il y a eu amélioration, faux sinon}
					\END
				\end{algo}
				\captionof{listing}{Algorithme de principe -- Déplacement d'un mobile au sein d'une autre tournée}
			\end{code}

			\begin{figure}[h!]
			\begin{subfigure}[b]{.54\linewidth}
				\centering
				\begin{tikzpicture}[schema]
					\input{move_move1route}
				\end{tikzpicture}
				\subcaption{Au sein d'une même tournée}
				\label{subfig:move_move1route}
			\end{subfigure}
			\hfill
			\begin{subfigure}[b]{.45\linewidth}
				\centering
				\begin{tikzpicture}[schema]
					\input{move_move2routes}
				\end{tikzpicture}
				\subcaption{Entre deux tournées}
				\label{subfig:move_move2routes}
			\end{subfigure}
			\caption{Schéma de déplacement d'un mobile}
			\label{fig:move_move}
			\end{figure}

		\subsection{Mouvements d'interversion (ou swap)}
			Le mouvement d'interversion ou swap consiste à échanger deux mobiles déjà présents dans une tournée. Il existe deux variantes de ce mouvement : lorsque les deux mobiles appartiennent à la même tournée ou lorsque les tournées sont différentes. Étant donné que ce mouvement ne peut pas diminuer le nombre de mobiles traités, le critère d'amélioration porte uniquement sur la réduction du temps final de la ou l'une des tournées considérées.

			L'algorithme de principe pour l'interversion dans une même tournée est le suivant:
			\begin{code}
				\begin{algo}[informal]
					\ALGO{Principe de l'interversion dans une tournée}
					\BEGIN
						\FORGEN{toutes les tournées t}
							\FORGEN{tous les mobiles m1 dans t}
								\FORGEN{tous les mobiles m2 après m1 dans t}
									\STATE{Calculer le nouveau temps d'interception de t avec m2 à la place de m1}
									\STATE{Comparer le résultat obtenu avec le temps initial (avec arrêt de la recherche selon les politiques)}
								\ENDFORGEN
							\ENDFORGEN
						\ENDFORGEN
						\RETURN{vrai s'il y a eu amélioration, faux sinon}
					\END
				\end{algo}
				\captionof{listing}{Algorithme de principe -- Interversion au sein d'une même tournée}
			\end{code}

			L'algorithme de principe pour l'interversion avec deux tournées est le suivant :
			\begin{code}
				\begin{algo}[informal]
					\ALGO{Principe de l'interversion entre 2 tournées}
					\BEGIN
						\FORGEN{toutes les tournées t1 sauf la dernière}
							\FORGEN{toutes les tournées t2 après t1}
								\FORGEN{tous les mobiles m1 dans t1}
									\FORGEN{tous les mobiles m2 dans t2}
										\STATE{Calculer le nouveau temps d'interception de t1 avec m2 à la place de m1}
										\STATE{Calculer le nouveau temps d'interception de t2 avec m1 à la place de m2}
										\STATE{Comparer les résultats obtenus avec les temps initiaux (avec arrêt de la recherche selon les politiques)}
									\ENDFORGEN
								\ENDFORGEN
							\ENDFORGEN
						\ENDFORGEN
						\RETURN{vrai s'il y a eu amélioration, faux sinon}
					\END
				\end{algo}
				\captionof{listing}{Algorithme de principe -- Interversion entre deux tournées}
			\end{code}


			\begin{figure}[h!]
			\begin{subfigure}[b]{.54\linewidth}
				\centering
				\begin{tikzpicture}[schema]
					\input{move_swap1route}
				\end{tikzpicture}
				\subcaption{Au sein d'une même tournée}
				\label{subfig:move_swap1route}
			\end{subfigure}
			\hfill
			\begin{subfigure}[b]{.45\linewidth}
				\centering
				\begin{tikzpicture}[schema]
					\input{move_swap2routes}
				\end{tikzpicture}
				\subcaption{Entre deux tournées}
				\label{subfig:move_swap2routes}
			\end{subfigure}
			\caption{Schéma d'interversion de deux mobiles}
			\label{fig:move_swap}
			\end{figure}

		\subsection{Mouvement d'interversion de fins de tournées (ou 2-Opt)}
			Le mouvement d'interversion de fin de tournée ou 2-Opt consiste à échanger deux séquences de mobiles dans deux tournées différentes. Les séquences considérées sont une suite de mobiles tels qu'ils ont été définis au sein d'une tournée, qu'il s'agisse de la tournée entière ou d'un ensemble à partir d'un mobile donné jusqu'à la fin de la tournée. Comme pour le mouvement d'interversion, le nombre de mobiles ne sera jamais réduit, seul le gain en temps est donc considéré. Un cas particulier de ce mouvement consiste à changer les intercepteurs de chaque tournée.

			L'algorithme de principe pour le mouvement 2-Opt est le suivant :
			\begin{code}
				\begin{algo}[informal]
					\ALGO{Principe du 2-Opt}
					\BEGIN
						\FORGEN{toutes les tournées t1 sauf la dernière}
							\FORGEN{toutes les tournées t2 après t1}
								\FORGEN{tous les mobiles m1 dans t1}
									\FORGEN{tous les mobiles m2 dans t2}
										\STATE{Calculer le nouveau temps d'interception de t1 en remplaçant la séquence [m1 à fin de tournée] par [m2 à fin de tournée]}
										\STATE{Calculer le nouveau temps d'interception de t2 en remplaçant la séquence [m2 à fin de tournée] par [m1 à fin de tournée]}
										\STATE{Comparer les résultats obtenus avec les temps initiaux (avec arrêt de la recherche selon les politiques)}
									\ENDFORGEN
								\ENDFORGEN
							\ENDFORGEN
						\ENDFORGEN
						\RETURN{vrai s'il y a eu amélioration, faux sinon}
					\END
				\end{algo}
				\captionof{listing}{Algorithme de principe -- 2-Opt}
			\end{code}

			\begin{figure}[h!]
			\centering
			\begin{tikzpicture}[schema]
				\input{move_2opt}
			\end{tikzpicture}
			\caption{Schéma d'interversion de fins de tournées}
			\label{fig:move_2opt}
			\end{figure}

		\subsection{Politiques d'amélioration}
			Afin de rendre les recherches plus pertinentes ou plus rapides, nous avons proposé des politiques permettant de piloter la validation d'une solution comme étant satisfaisante et de commander l'arrêt ou la poursuite des recherches pour trouver un mouvement améliorant. Ces politiques s'appliquent donc à la recherche locale.

			Nous tenons compte, pour valider (ou invalider) un mouvement, de bornes entrant dans le cadre de l'optimisation bi-critères. Un mouvement est considéré comme valide s'il n'implique pas de dépassement de ces bornes. 

			Les bornes concernent les deux critères \emph{nombre de mobiles interceptés} et \emph{date de fin de la pire tournée}. Elles sont gérées par l'utilisateur ou par le programme et peuvent être fixées pour atteindre ou dépasser un objectif non-négociable ou bien pour relaxer l'une ou l'autre, ou bien chacune des deux contraintes, jusqu'à un seuil choisi.

			Le principe de validation d'un mouvement est simple: il suffit de fournir à la politique les nouvelles valeurs de l'évaluation ainsi que les références que l'on refuse de dépasser. Ces références peuvent dans un premier temps être initialisées aux bornes que nous venons d'évoquer. En cas d'amélioration valide, la politique met à jour les références. Toutefois, elle ne modifie pas les bornes.

			\subsubsection{Politique du premier améliorant}
				\label{subs:first_available_policy}
				Cette politique demande l'arrêt des calculs dès lors qu'elle valide la première combinaison qui permet une amélioration au sens de l'optimisation bi-critères. 

				Elle offre des performances intéressantes en termes de vitesse d'exécution car elle permet de fournir une solution réalisable et améliorante tout en évitant de tester de nombreuses autres combinaisons.

			\subsubsection{Politique du meilleur améliorant}
				\label{subs:best_available_policy}
				Cette politique, contrairement à la précédente, nécessite de tester toutes les combinaisons possibles pour garder la meilleure. 

				Elle ne demande donc jamais l'arrêt des calculs, mais valide chaque amélioration plus intéressante que la meilleure des précédentes. La recherche se termine quand toutes les combinaisons ont été testées. Dès lors, la meilleure combinaison possible est connue, si elle existe, et peut être validée.


	\section{Méta-heuristiques}

	La recherche locale permet d'obtenir de bonnes améliorations au sein d'une solution déterminée, mais les algorithmes génétiques ajoutent la possibilité d'étendre la recherche de la meilleure solution à une multitude de solutions possibles.

	Les algorithmes génétiques vont insérer une perturbation (mutation) dans la solution étudiée qui va déterminer une population sur laquelle on va appliquer la recherche locale. Seuls les meilleurs résultats sont conservés et on réitère l'opération autant de fois que désiré.

		\subsection{Multi-Start Evolutionary Local Search}

		L'algorithme \emph{Multi-Start Evolutionary Local Search} (ou MS-ELS) est le premier  à avoir été implémenté pour notre solution. Le Multi-Start consiste à créer un certain nombre de solutions aléatoires à partir du problème et sur lesquelles on va appliquer une recherche local de type ELS. La génération des solutions se fait à partir de l'heuristique de construction séquentielle dont la séquence des mobiles donnée va être aléatoire.

		Puis l'Evolutionary Local Search va, pour un nombre d'itérations donné, perturber la solution avant d'y appliquer la recherche locale. On va alors sélectionner le meilleur résultat local trouvé et relancer l'ELS à de multiples reprises pour déterminer un record parmi le meilleur local de chaque ELS.

		À la fin, l'algorithme retourne la meilleure solution trouvée.

		Algorithme de principe :
		\begin{code}
			\begin{algo}[informal]
				\ALGO{Principe du Multi-Start Evolutionary Local Search}
				\BEGIN
					\FOR{i}{1}{nombre max de générations}
						\STATE{Créer une solution aléatoire}
						\STATE{Record ← solution}
						\FOR{j}{1}{nombre max d'itérations de l'ELS}
							\STATE{Meilleur local ← solution}
							\FOR{k}{1}{nombre max de copies}
								\STATE{Créer une copie de solution}
								\STATE{Créer une perturbation dans la copie (shake)}
								\STATE{Lancer la VND pour la copie}
								\IF{la copie donne un meilleur résultat}
									\STATE{Meilleur local ← copie}
								\ENDIF
							\ENDFOR
							\IF{le meilleur local donne un meilleur résultat que le record}
								\STATE{Record ← meilleur local}
							\ENDIF
						\ENDFOR
					\ENDFOR
					\RETURN{record}
				\END
			\end{algo}
			\captionof{listing}{Algorithme de principe -- MS-ELS}
		\end{code}

		\begin{figure}[h!]
			\centering
			\begin{tikzpicture}[node distance=1cm]
				\input{logigram_ms_els}
			\end{tikzpicture}
			\caption{Logigramme pour le MS-ELS}
			\label{fig:ms-els-logigram}
		\end{figure}


		\subsection{Biased Random-Key Genetic Algorithm}
	\section{Aspect gestion de projet}

	\begin{itemize}
		\item Plateforme de gestion de projet
		\item Soucis de retard
		\item Organisation
	\end{itemize}
