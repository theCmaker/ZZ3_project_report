\chapter{Résultats}

	Pour les générer les résultats de nos algorithmes, nous avons utilisé les instances présentées dans le tableau~\ref{tab:instances}.
	
	\begin{table}[h!]
		\centering
		\begin{tabular}{l|r|r|r|l}
		\cline{2-4}
                                                                     & \multicolumn{1}{c|}{\textbf{Mobiles}} & \multicolumn{1}{c|}{\textbf{Intercepteurs}} & \multicolumn{1}{c|}{\textbf{Dépôts}} &  \\ \cline{1-4}
            \multicolumn{1}{|l|}{\textbf{instance A}}   & 10                               & 2                               & 2                               &  \\ \cline{1-4}
            \multicolumn{1}{|l|}{\textbf{instance B}}   & 20                               & 3                               & 3                               &  \\ \cline{1-4}
            \multicolumn{1}{|l|}{\textbf{instance C}}   & 30                               & 4                               & 3                               &  \\ \cline{1-4}
            \multicolumn{1}{|l|}{\textbf{instance D}}   & 40                               & 5                               & 4                               &  \\ \cline{1-4}
            \multicolumn{1}{|l|}{\textbf{instance E}}   & 60                               & 8                               & 4                               &  \\ \cline{1-4}
            \multicolumn{1}{|l|}{\textbf{instance F}}  & 100                                & 8                               & 5                               &  \\ \cline{1-4}
            \multicolumn{1}{|l|}{\textbf{instance G}} & 1000                                & 40                           & 30                               &  \\ \cline{1-4}
            \end{tabular}
            \caption{Instances utilisées}
            \label{tab:instances}
        \end{table}
		

    \section{Avant améliorations}
        Nous avons comparé les performances de l'heuristique d'insertion au plus tôt dans les cas où elle fonctionne avec ou sans cache. Cela nous a permis de justifier de l'intérêt de ce cache, surtout sur de grosses instances. Nous avons donc mesuré les temps de calcul de l'heuristique sur différentes instances. Les résultats sont obtenus par moyennage sur 100 exécutions et sont présentés dans le tableau~\ref{tab:cache-perf}.

        \begin{table}[H]
            \centering
            \begin{tabular}{l|r|r|r|l}
            \cline{2-4}
                                                                     & \multicolumn{1}{c|}{\textbf{Avec Cache}} & \multicolumn{1}{c|}{\textbf{Sans Cache}} & \multicolumn{1}{c|}{\textbf{Gain en temps}} &  \\ \cline{1-4}
            \multicolumn{1}{|l|}{\textbf{instance A (10 mobiles)}}   & 32.291 µs                               & 53.106 µs                               & 39\%                               &  \\ \cline{1-4}
            \multicolumn{1}{|l|}{\textbf{instance B (20 mobiles)}}   & 137.305 µs                               & 274.566 µs                               & 50\%                               &  \\ \cline{1-4}
            \multicolumn{1}{|l|}{\textbf{instance C (30 mobiles)}}   & 268.857 µs                               & 760.437 µs                               & 65\%                               &  \\ \cline{1-4}
            \multicolumn{1}{|l|}{\textbf{instance D (40 mobiles)}}   & 487.622 µs                               & 1759.860 µs                               & 72\%                               &  \\ \cline{1-4}
            \multicolumn{1}{|l|}{\textbf{instance E (60 mobiles)}}   & 1212.790 µs                               & 6391.220 µs                               & 81\%                               &  \\ \cline{1-4}
            \multicolumn{1}{|l|}{\textbf{instance F (100 mobiles)}}  & 3038.210µs                                & 17595.600 µs                               & 83\%                               &  \\ \cline{1-4}
            \multicolumn{1}{|l|}{\textbf{instance G (1000 mobiles)}} & 486714.000 µs                                & 8.69975e+06 µs                           & 94\%                               &  \\ \cline{1-4}
            \end{tabular}
            \caption{Performances du cache}
            \label{tab:cache-perf}
        \end{table}
    	
    	La mise en place de ce cache permet d'obtenir de très gros gains de temps, comme l'indique la troisième colonne du tableau~\ref{tab:cache-perf}. Il s'agit d'une amélioration importante puisque dans le cadre d'un problème NP-Difficile, le souci de gagner du temps dans l'exécution du programme se trouve au coeur du problème.
    	
    	Quelques corrections et améliorations ont aussi étaient apportées dans les heurisitiques de construction et notammment dans le calcul du temps d'interception, permettant d'accélérer les calculs. L'heuristique de construction par séquence est moins performante que celle d'insertion au plus tôt, mais elle permet de construire différentes solutions à la différence de la deuxième qui renverra toujours la même solution pour chaque problème donné.
    	
    \section{Après améliorations}
    	\subsection{Résultats de la VND}
		
		Les résultats obtenus par la \acrlong{vnd} pour chacune des instances sont exposés dans le tableau~\ref{tab:vnd-perf}. Le calibrage de la VND a permis d'arriver à des résultats intéressants, car l'amélioration de la solution initiale obtenue donne une solution qui intercepte presque tous les mobiles dans un temps plutôt restreint. 
		
		L'exécution de la VND est assez rapide, même sur de grosses instances.
		
        \begin{table}[H]
            \centering
            \begin{tabular}{l|r|r|r|}
            \cline{2-4}
            \multirow{2}{*}{}                         & \multicolumn{3}{c|}{\textbf{VND\textless30\textgreater}}                                                            \\ \cline{2-4} 
                                                      & \multicolumn{1}{c|}{\textbf{Temps}} & \multicolumn{1}{c|}{\textbf{\#ratés}} & \multicolumn{1}{c|}{\textbf{tps max}} \\ \hline
            \multicolumn{1}{|l|}{\textbf{instance A}} & 1258 µs                             & 0                                     & 12.5073                               \\ \hline
            \multicolumn{1}{|l|}{\textbf{instance B}} & 28770 µs                            & 0                                     & 12.2847                               \\ \hline
            \multicolumn{1}{|l|}{\textbf{instance C}} & 18097 µs                            & 2                                     & 13.8550                               \\ \hline
            \multicolumn{1}{|l|}{\textbf{instance D}} & 49436 µs                            & 0                                     & 30.2055                               \\ \hline
            \multicolumn{1}{|l|}{\textbf{instance E}} & 235459 µs                           & 0                                     & 28.4949                               \\ \hline
            \multicolumn{1}{|l|}{\textbf{instance F}} & 938703 µs                           & 0                                     & 71.9546                               \\ \hline
            \multicolumn{1}{|l|}{\textbf{instance G}} & 200 s                               & 0                                     & 288.2480                                       \\ \hline
            \end{tabular}
            \caption{Résultats et performances de la VND}
            \label{tab:vnd-perf}
        \end{table}

    	\subsection{Résultats du MS-ELS}
    	
    	Le tableau~\ref{tab:msels} présente les résultats obtenus avec la métaheuristique MS-ELS. Les résultats ne sont pas aussi bons qu'espérés, car le critère de sélection de la meilleure solution a tendance à privilégier le temps par rapport au nombre de mobiles interceptés. Il serait donc intéressant de revoir l'évalution des solutions pour obtenir de meilleurs résultats. De plus, la MS-ELS est un algorithme mono-objectif, ce qui le rend aussi moins avantageux, car on devra se contenter d'une agrégation entre les critères plutôt que d'une véritable recherche bi-objective.
    	
    C'est pour cette raison que nous n'avons pas concentré notre travail sur l'amélioration de cette métaheurisque et qu'à la place, nous avons implémenté un algorithme génétique fondé sur la recherche d'un ensemble de solutions qui répondraient à la fois au critère de temps et à celui du nombre de mobiles interceptés.
    	
            \begin{table}[H]
                \centering
                \begin{tabular}{l|r|r|r|r|r|r|r|r|r|}
                \cline{2-10}
                                                                       & \multicolumn{3}{c|}{\textbf{MS\_ELS\textless5,5,10,VND\textless30\textgreater\textgreater}}                                           & \multicolumn{3}{c|}{\textbf{MS\_ELS\textless2,5,25,VND\textless30\textgreater\textgreater}}                                           & \multicolumn{3}{c|}{\textbf{MS\_ELS\textless5,5,10,MY\_VND\textgreater}}                                                              \\ \cline{2-10} 
                                                                       & \multicolumn{1}{c|}{\textbf{Temps}} & \multicolumn{1}{c|}{\textbf{\#ratés}} & \multicolumn{1}{c|}{\textbf{tps max}} & \multicolumn{1}{c|}{\textbf{Temps}} & \multicolumn{1}{c|}{\textbf{\#ratés}} & \multicolumn{1}{c|}{\textbf{tps max}} & \multicolumn{1}{c|}{\textbf{Temps}} & \multicolumn{1}{c|}{\textbf{\#ratés}} & \multicolumn{1}{c|}{\textbf{tps max}} \\ \hline
                \multicolumn{1}{|l|}{\textbf{instance A}} & 0.2543 s                            & 0                                             & 7.0879                                          & 0.1808 s                            & 0                                             & 7.0879                                          & 0.1851 s                            & 0                                             & 8.1061                                          \\ \hline
                \multicolumn{1}{|l|}{\textbf{instance B}} & 4.01897 s                           & 0                                             & 15.3857                                         & 3.6432 s                            & 0                                             & 15.3857                                         & 2.3309 s                            & 0                                             & 16.2300                                         \\ \hline
                \multicolumn{1}{|l|}{\textbf{instance C}} & 3.10806 s                           & 7                                             & 10.5255                                         & 2.2898 s                            & 5                                             & 16.9429                                         & 1.2665 s                            & 7                                             & 9.7625                                          \\ \hline
                \multicolumn{1}{|l|}{\textbf{instance D}} & 12.8920 s                           & 9                                             & 12.5229                                         & 13.2740 s                           & 10                                            & 15.7405                                         & 6.1521 s                            & 10                                            & 18.7669                                         \\ \hline
                \multicolumn{1}{|l|}{\textbf{instance E}} & 60.8356 s                           & 0                                             & 15.2699                                         & 60.4432 s                           & 0                                             & 15.7747                                         & 18.1701 s                           & 0                                             & 13.4661                                         \\ \hline
                \end{tabular}
                \caption{Résultats et performances du MS-ELS}
                \label{tab:msels}
            \end{table} 

        \subsection{Résultats du BRKGA}
			
			Le \acrlong{brkga} a été exécuté sans l'utilisation de la \acrshort{vnd} pour obtenir différentes solutions à chaque insertion d'un mobile et définir un front de Pareto initial. Ensuite le programme est lancé sur une instance avec la VND intégrée et l'algorithme génétique va effectuer un certain nombre d'appels à celle-ci pour 100 itérations.
			
			En terme de performances, le BRKGA sans VND s'exécute très rapidement et avec VND dans un temps plutôt raisonnable, même pour des instances plus importantes. Le tableau~\ref{tab:brkga} présente les résultats obtenus sur quatre instances comportants un nombre différent de mobiles et d'intercepteurs.
			
            \begin{table}[H]
                \centering
                \begin{tabular}{r|r|r|r|r|r|l}
                \cline{2-6}
                \multicolumn{1}{l|}{\multirow{2}{*}{}}                 & \multicolumn{2}{c|}{\textbf{BRKGA -- SANS VND}}                                  & \multicolumn{3}{c|}{\textbf{BRKGA -- AVEC VND}}                                                                                &  \\ \cline{2-6}
                \multicolumn{1}{l|}{}                                  & \multicolumn{1}{c|}{\textit{temps}} & \multicolumn{1}{c|}{\textit{\# solutions}} & \multicolumn{1}{c|}{\textit{temps}} & \multicolumn{1}{c|}{\textit{\# solutions}} & \multicolumn{1}{c|}{\textit{\# appels VND}} &  \\ \cline{1-6}
                \multicolumn{1}{|l|}{\textbf{instance A (10 mobiles)}} & 1.30s                               & 10                                         & 367.37s                             & 18                                         & 247729                                      &  \\ \cline{1-6}
                \multicolumn{1}{|l|}{\textbf{instance B (20 mobiles)}} & 1.34s                               & 20                                         & 1046.95s                            & 20                                         & 336071                                      &  \\ \cline{1-6}
                \multicolumn{1}{|l|}{\textbf{instance C (30 mobiles)}} & 1.98s                               & 22                                         & 339.88s                             & 6                                          & 183920                                      &  \\ \cline{1-6}
                \multicolumn{1}{|l|}{\textbf{instance D (40 mobiles)}} & 8.93s                               & 34                                         & 5656.13s                            & 20                                         & 382957                                      &  \\ \cline{1-6}
                \end{tabular}
                \caption{Résultats et performances de BRKGA}
                \label{tab:brkga}
            \end{table}
            
            Les graphiques suivants présentent les résultats obtenus par le BRKGA sans la VND puis avec la VND. Sur toutes les instances testées, on observe une réduction très nette de l'hypervolume, notamment concernant les solutions qui interceptent un grand nombre de mobiles (côté gauche), car elles parviennent à le faire dans un temps maximal beaucoup plus court que lors des premiers résultats obtenus.
            
            On peut donc en déduire que l'algorithme génétique nous permet d'obtenir de très bonnes améliorations en un temps raisonnable et qu'il démontre la possibilité de résoudre rapidement un problème de STDVRP.
            
            \subsubsection{10m2i2d}
                
                \begin{figure}[H]
                	\input{brkga_10m2i2d_novnd_pareto}
                \caption{Résultat du BRKGA sans VND pour un problème avec 10 mobiles, 2 intercepteurs et 2 dépôts}
				\label{fig:10m2i2d-sansvnd}
				\end{figure}
                
                \begin{figure}[H]
                	\input{brkga_10m2i2d_vnd_pareto}
                \caption{Résultat du BRKGA avec VND pour un problème avec 10 mobiles, 2 intercepteurs et 2 dépôts}
				\label{fig:10m2i2d-avecvnd}
				\end{figure}
				
            \subsubsection{20m3i3d}
                \begin{figure}[H]
                	\input{brkga_20m3i3d_novnd_pareto}
                \caption{Résultat du BRKGA sans VND pour un problème avec 20 mobiles, 3 intercepteurs et 3 dépôts}
				\label{fig:20m3i3d-sansvnd}
				\end{figure}
                
                \begin{figure}[H]
                	\input{brkga_20m3i3d_vnd_pareto}
                \caption{Résultat du BRKGA avec VND pour un problème avec 20 mobiles, 3 intercepteurs et 3 dépôts}
				\label{fig:20m3i3d-avecvnd}
				\end{figure}
				
            \subsubsection{30m4i3d}
           		\begin{figure}[H]
                	\input{brkga_30m4i3d_novnd_pareto}
                \caption{Résultat du BRKGA sans VND pour un problème avec 30 mobiles, 4 intercepteurs et 3 dépôts}
				\label{fig:30m4i3d-sansvnd}
                \end{figure}
                
                \begin{figure}[H]
                	\input{brkga_30m4i3d_vnd_pareto}
                \caption{Résultat du BRKGA avec VND pour un problème avec 30 mobiles, 4 intercepteurs et 3 dépôts}
				\label{fig:30m4i3d-avecvnd}
				\end{figure}
				
            \subsubsection{40m5i4d}
            	\begin{figure}[H]
                	\input{brkga_40m5i4d_novnd_pareto}
                \caption{Résultat du BRKGA sans VND pour un problème avec 40 mobiles, 5 intercepteurs et 4 dépôts}
				\label{fig:40m5i4d-sansvnd}
                \end{figure}
                
                \begin{figure}[H]
                	\input{brkga_40m5i4d_vnd_pareto}
                \caption{Résultat du BRKGA avec VND pour un problème avec 40 mobiles, 5 intercepteurs et 4 dépôts}
				\label{fig:40m5i4d-avecvnd}
				\end{figure}
				

    \section{Perspectives}
    
    	\begin{itemize}
    		\item amélioration du MS-ELS (critère de sélection des meilleures solutions -> il favorise pour l'instant le temps et donne des résultats moins bons + problème du mono critère)
    		\item ajout de l'incertitude (loi de Poisson ou loin exponentielle négative ?)
    		\item multi-thread des métaheuristiques pour augmenter les performances de calcul
    	\end{itemize}
    		
