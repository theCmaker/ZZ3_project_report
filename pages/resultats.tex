\chapter{Résultats}
\label{chap:resultats}

	Pour les générer les résultats de nos algorithmes, nous avons utilisé les instances présentées dans le tableau~\ref{tab:instances}.
	
	\begin{table}[h!]
		\centering
		\begin{tabular}{l|r|r|r|l}
		\cline{2-4}
                                                                     & \multicolumn{1}{c|}{\textbf{Mobiles}} & \multicolumn{1}{c|}{\textbf{Intercepteurs}} & \multicolumn{1}{c|}{\textbf{Dépôts}} &  \\ \cline{1-4}
            \multicolumn{1}{|l|}{\textbf{instance A}}   & 10                               & 2                               & 2                               &  \\ \cline{1-4}
            \multicolumn{1}{|l|}{\textbf{instance B}}   & 20                               & 3                               & 3                               &  \\ \cline{1-4}
            \multicolumn{1}{|l|}{\textbf{instance C}}   & 30                               & 4                               & 3                               &  \\ \cline{1-4}
            \multicolumn{1}{|l|}{\textbf{instance D}}   & 40                               & 5                               & 4                               &  \\ \cline{1-4}
            \multicolumn{1}{|l|}{\textbf{instance E}}   & 60                               & 8                               & 4                               &  \\ \cline{1-4}
            \multicolumn{1}{|l|}{\textbf{instance F}}  & 100                                & 8                               & 5                               &  \\ \cline{1-4}
            \multicolumn{1}{|l|}{\textbf{instance G}} & 1000                                & 40                           & 30                               &  \\ \cline{1-4}
            \end{tabular}
            \caption{Instances utilisées}
            \label{tab:instances}
        \end{table}
		

    \section{Avant améliorations}
        Nous avons comparé les performances de l'heuristique d'insertion au plus tôt dans les cas où elle fonctionne avec ou sans cache. Cela nous a permis de justifier de l'intérêt de ce cache, surtout sur de grosses instances. Nous avons donc mesuré les temps de calcul de l'heuristique sur différentes instances. Les résultats sont obtenus par moyennage sur 100 exécutions et sont présentés dans le tableau~\ref{tab:cache-perf}.

        \begin{table}[H]
            \centering
            \begin{tabular}{l|r|r|r|l}
            \cline{2-4}
                                                                     & \multicolumn{1}{c|}{\textbf{Avec Cache}} & \multicolumn{1}{c|}{\textbf{Sans Cache}} & \multicolumn{1}{c|}{\textbf{Gain en temps}} &  \\ \cline{1-4}
            \multicolumn{1}{|l|}{\textbf{instance A (10 mobiles)}}   & 32.291 µs                               & 53.106 µs                               & 39\%                               &  \\ \cline{1-4}
            \multicolumn{1}{|l|}{\textbf{instance B (20 mobiles)}}   & 137.305 µs                               & 274.566 µs                               & 50\%                               &  \\ \cline{1-4}
            \multicolumn{1}{|l|}{\textbf{instance C (30 mobiles)}}   & 268.857 µs                               & 760.437 µs                               & 65\%                               &  \\ \cline{1-4}
            \multicolumn{1}{|l|}{\textbf{instance D (40 mobiles)}}   & 487.622 µs                               & 1759.860 µs                               & 72\%                               &  \\ \cline{1-4}
            \multicolumn{1}{|l|}{\textbf{instance E (60 mobiles)}}   & 1212.790 µs                               & 6391.220 µs                               & 81\%                               &  \\ \cline{1-4}
            \multicolumn{1}{|l|}{\textbf{instance F (100 mobiles)}}  & 3038.210µs                                & 17595.600 µs                               & 83\%                               &  \\ \cline{1-4}
            \multicolumn{1}{|l|}{\textbf{instance G (1000 mobiles)}} & 0.486 s                                & 8.699 s                           & 94\%                               &  \\ \cline{1-4}
            \end{tabular}
            \caption{Performances du cache}
            \label{tab:cache-perf}
        \end{table}
    	
    	La mise en place de ce cache permet d'obtenir de très gros gains de temps, comme l'indique la troisième colonne du tableau~\ref{tab:cache-perf}. Il s'agit d'une amélioration importante puisque dans le cadre d'un problème NP-Difficile, le souci de gagner du temps dans l'exécution du programme se trouve au coeur du problème.
    	
    	Quelques corrections et améliorations ont aussi été apportées dans les heuristiques de construction et notammment dans le calcul du temps d'interception, permettant d'accélérer les calculs. L'heuristique de construction par séquence est moins pertinente que celle d'insertion au plus tôt, mais elle permet de construire différentes solutions à la différence de la deuxième qui renverra toujours la même solution pour chaque problème donné.
    	
    \section{Après améliorations}
    	\subsection{Résultats de la VND}
		
		Les résultats obtenus par la \acrlong{vnd} pour chacune des instances sont exposés dans le tableau~\ref{tab:vnd-perf}. Le calibrage de la VND a permis d'arriver à des résultats intéressants, car l'amélioration de la solution initiale obtenue donne une solution qui intercepte presque tous les mobiles dans un temps plutôt restreint. 
		
		L'exécution de la VND est assez rapide, même sur de grosses instances.
		
        \begin{table}[H]
            \centering
            \begin{tabular}{l|r|r|r|}
            \cline{2-4}
            \multirow{2}{*}{}                         & \multicolumn{3}{c|}{\textbf{VND\textless30\textgreater}}                                                            \\ \cline{2-4} 
                                                      & \multicolumn{1}{c|}{\textbf{Temps}} & \multicolumn{1}{c|}{\textbf{\#ratés}} & \multicolumn{1}{c|}{\textbf{tps max}} \\ \hline
            \multicolumn{1}{|l|}{\textbf{instance A}} & 1258 µs                             & 0                                     & 12.5073                               \\ \hline
            \multicolumn{1}{|l|}{\textbf{instance B}} & 28770 µs                            & 0                                     & 12.2847                               \\ \hline
            \multicolumn{1}{|l|}{\textbf{instance C}} & 18097 µs                            & 2                                     & 13.8550                               \\ \hline
            \multicolumn{1}{|l|}{\textbf{instance D}} & 49436 µs                            & 0                                     & 30.2055                               \\ \hline
            \multicolumn{1}{|l|}{\textbf{instance E}} & 235459 µs                           & 0                                     & 28.4949                               \\ \hline
            \multicolumn{1}{|l|}{\textbf{instance F}} & 938703 µs                           & 0                                     & 71.9546                               \\ \hline
            \multicolumn{1}{|l|}{\textbf{instance G}} & 200 s                               & 0                                     & 288.2480                                       \\ \hline
            \end{tabular}
            \caption{Résultats et performances de la VND}
            \label{tab:vnd-perf}
        \end{table}

    	\subsection{Résultats du MS-ELS}
    	
    	Le tableau~\ref{tab:msels} présente les résultats obtenus avec la métaheuristique MS-ELS. Les résultats ne sont pas aussi bons qu'espérés, car le critère de sélection de la meilleure solution a tendance à privilégier le temps par rapport au nombre de mobiles interceptés. Il serait donc intéressant de revoir l'évaluation des solutions pour obtenir de meilleurs résultats. De plus, la MS-ELS est un algorithme mono-objectif, ce qui le rend aussi moins avantageux, car on doit se contenter d'une agrégation entre les critères plutôt que d'une véritable recherche bi-objective.
    	
    C'est pour cette raison que nous n'avons pas concentré notre travail sur l'amélioration de cette métaheurisque et qu'à la place, nous avons implémenté un algorithme génétique fondé sur la recherche d'un ensemble de solutions qui répondraient à la fois au critère de temps et à celui du nombre de mobiles interceptés.
    	
            \begin{table}[H]
                \centering
                \begin{tabular}{l|r|r|r|r|r|r|r|r|r|}
                \cline{2-10}
                                                                       & \multicolumn{3}{c|}{\textbf{MS\_ELS\textless5,5,10,VND\textless30\textgreater\textgreater}}                                           & \multicolumn{3}{c|}{\textbf{MS\_ELS\textless2,5,25,VND\textless30\textgreater\textgreater}}                                           & \multicolumn{3}{c|}{\textbf{MS\_ELS\textless5,5,10,MY\_VND\textgreater}}                                                              \\ \cline{2-10} 
                                                                       & \multicolumn{1}{c|}{\textbf{Temps}} & \multicolumn{1}{c|}{\textbf{\#ratés}} & \multicolumn{1}{c|}{\textbf{tps max}} & \multicolumn{1}{c|}{\textbf{Temps}} & \multicolumn{1}{c|}{\textbf{\#ratés}} & \multicolumn{1}{c|}{\textbf{tps max}} & \multicolumn{1}{c|}{\textbf{Temps}} & \multicolumn{1}{c|}{\textbf{\#ratés}} & \multicolumn{1}{c|}{\textbf{tps max}} \\ \hline
                \multicolumn{1}{|l|}{\textbf{inst. A}} & 0.2543 s                            & 0                                             & 7.0879                                          & 0.1808 s                            & 0                                             & 7.0879                                          & 0.1851 s                            & 0                                             & 8.1061                                          \\ \hline
                \multicolumn{1}{|l|}{\textbf{inst. B}} & 4.01897 s                           & 0                                             & 15.3857                                         & 3.6432 s                            & 0                                             & 15.3857                                         & 2.3309 s                            & 0                                             & 16.2300                                         \\ \hline
                \multicolumn{1}{|l|}{\textbf{inst. C}} & 3.10806 s                           & 7                                             & 10.5255                                         & 2.2898 s                            & 5                                             & 16.9429                                         & 1.2665 s                            & 7                                             & 9.7625                                          \\ \hline
                \multicolumn{1}{|l|}{\textbf{inst. D}} & 12.8920 s                           & 9                                             & 12.5229                                         & 13.2740 s                           & 10                                            & 15.7405                                         & 6.1521 s                            & 10                                            & 18.7669                                         \\ \hline
                \multicolumn{1}{|l|}{\textbf{inst. E}} & 60.8356 s                           & 0                                             & 15.2699                                         & 60.4432 s                           & 0                                             & 15.7747                                         & 18.1701 s                           & 0                                             & 13.4661                                         \\ \hline
                \end{tabular}
                \caption{Résultats et performances du MS-ELS}
                \label{tab:msels}
            \end{table} 

        \subsection{Résultats du BRKGA}
			
			Le \acrlong{brkga} a été exécuté sans l'utilisation de la \acrshort{vnd} pour obtenir différentes solutions à chaque insertion d'un mobile et définir un front de Pareto initial. Ensuite le programme applique la VND après l'heuristique de construction et l'algorithme génétique va effectuer un certain nombre d'appels à cette VND. Dans nos tests, BRKGA itère 100 fois (mutations de la population). Sa population contient 128 chromosomes. La VND appliquée est fixée à 20 itérations au maximum.
			
			En termes de performances, le BRKGA sans VND s'exécute très rapidement et avec VND dans un temps plutôt raisonnable, même pour des instances plus importantes. Le tableau~\ref{tab:brkga} présente les résultats obtenus sur quatre instances comportant un nombre différent de mobiles et d'intercepteurs.
			
            \begin{table}[H]
                \centering
                \begin{tabular}{r|r|r|r|r|r|l}
                \cline{2-6}
                \multicolumn{1}{l|}{\multirow{2}{*}{}}                 & \multicolumn{2}{c|}{\textbf{BRKGA -- SANS VND}}                                  & \multicolumn{3}{c|}{\textbf{BRKGA -- AVEC VND<20>}}                                                                                &  \\ \cline{2-6}
                \multicolumn{1}{l|}{}                                  & \multicolumn{1}{c|}{\textit{temps}} & \multicolumn{1}{c|}{\textit{\# solutions}} & \multicolumn{1}{c|}{\textit{temps}} & \multicolumn{1}{c|}{\textit{\# solutions}} & \multicolumn{1}{c|}{\textit{\# appels VND}} &  \\ \cline{1-6}
                \multicolumn{1}{|l|}{\textbf{instance A (10 mobiles)}} & 1.30s                               & 10                                         & 367.37s                             & 18                                         & 247729                                      &  \\ \cline{1-6}
                \multicolumn{1}{|l|}{\textbf{instance B (20 mobiles)}} & 1.34s                               & 20                                         & 1046.95s                            & 20                                         & 336071                                      &  \\ \cline{1-6}
                \multicolumn{1}{|l|}{\textbf{instance C (30 mobiles)}} & 1.98s                               & 22                                         & 339.88s                             & 6                                          & 183920                                      &  \\ \cline{1-6}
                \multicolumn{1}{|l|}{\textbf{instance D (40 mobiles)}} & 8.93s                               & 34                                         & 5656.13s                            & 20                                         & 382957                                      &  \\ \cline{1-6}
                \end{tabular}
                \caption{Résultats et performances du BRKGA}
                \label{tab:brkga}
            \end{table}
            
            Les graphiques suivants présentent les résultats obtenus par le BRKGA sans la VND puis avec la VND. Sur toutes les instances testées, on observe une réduction très nette de l'hypervolume, notamment concernant les solutions qui interceptent un grand nombre de mobiles (côté gauche), car elles parviennent à le faire dans un temps maximal beaucoup plus court que lors des premiers résultats obtenus.
            
            On peut donc en déduire que l'algorithme génétique nous permet d'obtenir de très bonnes améliorations en un temps raisonnable et qu'il démontre la possibilité de résoudre rapidement un problème de STDVRP.

            Le front de Pareto est représenté en bleu et l'hypervolume correspond à la surface en rouge.
            
            \subsubsection{Instance A}
                
                \begin{figure}[H]
                	\input{brkga_10m2i2d_novnd_pareto}
                \caption{Résultat du BRKGA sans VND pour l'instance A}
				\label{fig:10m2i2d-sansvnd}
				\end{figure}
                
                \begin{figure}[H]
                	\input{brkga_10m2i2d_vnd_pareto}
                \caption{Résultat du BRKGA avec VND pour l'instance A}
				\label{fig:10m2i2d-avecvnd}
				\end{figure}
				
            \subsubsection{Instance B}
                \begin{figure}[H]
                	\input{brkga_20m3i3d_novnd_pareto}
                \caption{Résultat du BRKGA sans VND pour l'instance B}
				\label{fig:20m3i3d-sansvnd}
				\end{figure}
                
                \begin{figure}[H]
                	\input{brkga_20m3i3d_vnd_pareto}
                \caption{Résultat du BRKGA avec VND pour l'instance B}
				\label{fig:20m3i3d-avecvnd}
				\end{figure}
				
            \subsubsection{Instance C}
           		\begin{figure}[H]
                	\input{brkga_30m4i3d_novnd_pareto}
                \caption{Résultat du BRKGA sans VND pour l'instance C}
				\label{fig:30m4i3d-sansvnd}
                \end{figure}
                
                \begin{figure}[H]
                	\input{brkga_30m4i3d_vnd_pareto}
                \caption{Résultat du BRKGA avec VND pour l'instance C}
				\label{fig:30m4i3d-avecvnd}
				\end{figure}
				
            \subsubsection{Instance D}
            	\begin{figure}[H]
                	\input{brkga_40m5i4d_novnd_pareto}
                \caption{Résultat du BRKGA sans VND pour l'instance D}
				\label{fig:40m5i4d-sansvnd}
                \end{figure}
                
                \begin{figure}[H]
                	\input{brkga_40m5i4d_vnd_pareto}
                \caption{Résultat du BRKGA avec VND pour l'instance D}
				\label{fig:40m5i4d-avecvnd}
				\end{figure}
				
    \newpage
    \section{Perspectives}

        Nous sommes parvenus à implémenter des méthodes qui fournissent des résultats intéressants, mais parfois instables. C'est notamment le cas du MS-ELS, qui favorise trop le temps par rapport au nombre de mobiles à intercepter. Les résultats s'en voient détériorés. Une amélioration est donc possible pour une meilleure gestion du facteur bi-critères. En effet, l'algorithme a un fonctionnement proche de celui que l'on pourrait obtenir en ne considérant qu'un seul critère, il est donc perfectible.

        Notre modèle propose déjà un certain nombre de fonctionnalités comme l'autonomie des intercepteurs et la possibilité d'une flotte non-homogène. On pourrait toutefois lui ajouter plus de réalisme quant au calcul des dates d'interception en introduisant par exemple un aléa (loi de Poisson ou loi exponentielle négative). Nous n'avons pas eu le temps de développer cette fonctionnalité.

        Par ailleurs, tous nos programmes sont exécutés sur un seul \emph{thread}, il serait pertinent d'adapter certains éléments pour permettre une exécution \emph{multi-threads} et ainsi apporter un gain significatif en temps d'exécution et donc en performances. On remarque que les méta-heuristiques demandent beaucoup de ressources quand les instances grossissent, aussi leur exécution n'en sera que facilitée.
